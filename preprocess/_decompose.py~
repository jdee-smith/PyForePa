import numpy as np

from helpers._helpers import (trend, detrend, seasonality, remainder)


def decompose_trend(self, order='default', center=True):
    """
    Returns array consisting of series trend.
    """
    data = self.y_transformed
    order = self.season if order is 'default' else order

    trends = decompose_trend(data, order, center)

    return trends


def decompose_detrend(self, order='default', center=True, model='additive'):
    """
    Returns array of detrended series.
    """
    data = self.y_transformed
    order = self.season if order is 'default' else order
    k = len(data)

    if model == 'additive':
        data_detrended = data.reshape(
            k, 1) - decompose_trend(data, order, center)
    elif model == 'multiplicative':
        data_detrended = data.reshape(
            k, 1) / decompose_trend(data, order, center)
    else:
        raise ValueError('Model must be additive or multiplicative.')

    return data_detrended


def decompose_seasonality(
    self, order='default', center=True, model='additive', median='False'
):
    """
    Returns array of series seasonality.
    """
    data = self.y_transformed
    order = self.season if order is 'default' else order
    n_rows = int(len(data) / order)
    n_cols = order

    detrended_series = decompose_detrend(data, order, center, model)

    if median == 'False':
        mat = np.nanmean(np.matrix(detrended_series).reshape(
            [n_rows, n_cols]), axis=0).T
    else:
        mat = np.nanmedian(np.matrix(detrended_series).reshape(
            [n_rows, n_cols]), axis=0).T

    seasonality = np.array(np.tile(mat, (n_rows, 1)))

    return seasonality


def decompose_remainder(
    self, order='default', center=True, model='additive', median='False'
):
    """
    Returns array of left behind random noise.
    """
    data = self.y_transformed
    order = self.season if order is 'default' else order
    k = len(data)
    trend = decompose_trend(data, order, center)
    seasonality = decompose_seasonality(data, order, center, model, median)

    if model == 'additive':
        remainder = data.reshape(k, 1) - trend - seasonality
    elif model == 'multiplicative':
        remainder = data.reshape(k, 1) / (trend * seasonality)
    else:
        raise ValueError('Model must be additive or multiplicative.')

    return remainder


def decompose_detrend2(self, order='default', center=True, model='additive'):
    """
    Returns array of detrended series.
    """
    data = self.y_transformed
    order = self.season if order is 'default' else order
    k = len(data)

    if model == 'additive':
        data_detrended = data.reshape(
            k, 1) - decompose_trend(data, order, center)
    elif model == 'multiplicative':
        data_detrended = data.reshape(
            k, 1) / decompose_trend(data, order, center)
    else:
        raise ValueError('Model must be additive or multiplicative.')

    return data_detrended
